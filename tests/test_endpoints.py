"""
Integration tests for API endpoints in dmca-light-api.

Generated by The Anvil S+++ Constitutional AGI Genesis Engine.
Version: 0.1.0

[!] CRITICAL: This file is auto-generated. Do not edit manually.
    To modify tests, update the Anvil specification YAML and regenerate.
"""

from fastapi.testclient import TestClient

from app.main import app

client = TestClient(app)


class TestHealthEndpoint:
    """Test health check endpoint"""

    def test_health_check(self):
        """Test health check returns 200 OK"""
        response = client.get("/api/v1/health")

        assert response.status_code == 200
        data = response.json()
        assert data["success"] is True
        assert data["message"] == "Service is healthy"
        assert "timestamp" in data["data"]
        assert data["data"]["version"] == "0.1.0"
        assert data["data"]["project"] == "dmca-light-api"


class TestMaterialsEndpoints:
    """Test cases for materials endpoints"""

    def test_list_materials(self):
        """Test list_materials endpoint"""
        response = client.get("/api/v1/materials/")

        assert response.status_code == 200
        data = response.json()

        # Pagination fields
        assert "total" in data
        assert "page" in data
        assert "page_size" in data
        assert "items" in data
        assert isinstance(data["items"], list)

    def test_list_materials_pagination(self):
        """Test list_materials pagination parameters"""
        response = client.get("/api/v1/materials/?page=1&page_size=10")

        assert response.status_code == 200
        data = response.json()
        assert data["page"] == 1
        assert data["page_size"] == 10

    def test_list_materials_invalid_pagination(self):
        """Test list_materials with invalid pagination"""
        response = client.get("/api/v1/materials/?page=0&page_size=-1")

        assert response.status_code == 422  # Validation error

    def test_get_material_success(self):
        """Test get_material with valid ID"""
        response = client.get("/api/v1/materials/1")

        # TODO: Mock database to return actual data
        # For now, expecting 404 (no data)
        assert response.status_code in [200, 404]

    def test_get_material_not_found(self):
        """Test get_material with non-existent ID"""
        response = client.get("/api/v1/materials/99999")

        assert response.status_code == 404

    def test_create_material_success(self):
        """Test create_material with valid data"""
        payload = {
            "id": 1,
            "name": "Gallium Arsenide",
            "formula": "GaAs",
            "band_gap": 1.42,
            "epsilon": 12.9,
            "effective_mass_e": 0.067,
            "effective_mass_h": 0.45,
            "lattice_constant": 5.65,
        }

        response = client.post("/api/v1/materials", json=payload)

        assert response.status_code in [200, 201]
        data = response.json()
        assert data["success"] is True
        assert "data" in data
        assert data["data"]["name"] == "Gallium Arsenide"
        assert data["data"]["formula"] == "GaAs"

    def test_create_material_invalid_data(self):
        """Test create_material with invalid data"""
        payload = {}  # Empty payload

        response = client.post("/api/v1/materials", json=payload)

        assert response.status_code == 422  # Validation error

    def test_create_material_invalid_band_gap(self):
        """Test create_material with negative band gap"""
        payload = {
            "id": 2,
            "name": "Invalid Material",
            "formula": "XX",
            "band_gap": -1.0,  # Invalid: negative
            "epsilon": 10.0,
            "effective_mass_e": 0.1,
            "effective_mass_h": 0.1,
            "lattice_constant": 5.0,
        }

        response = client.post("/api/v1/materials", json=payload)

        # Should accept it (no validation for negative yet)
        # In production, add validator
        assert response.status_code in [200, 201, 422]


class TestCalculationsEndpoints:
    """Test cases for calculations endpoints"""

    def test_calculate_exciton_success(self):
        """Test calculate_exciton with valid GaAs data"""
        payload = {
            "id": 1,
            "name": "Gallium Arsenide",
            "formula": "GaAs",
            "band_gap": 1.42,
            "epsilon": 12.9,
            "effective_mass_e": 0.067,
            "effective_mass_h": 0.45,
            "lattice_constant": 5.65,
        }

        response = client.post("/api/v1/calculate/exciton", json=payload)

        assert response.status_code in [200, 201]
        data = response.json()

        # Check result structure
        assert "binding_energy" in data
        assert "bohr_radius" in data
        assert "material_id" in data
        assert "calculated_at" in data

        # Physics validation: binding energy should be positive
        assert data["binding_energy"] > 0
        # GaAs binding energy is typically ~4 meV = 0.004 eV
        assert 0.001 < data["binding_energy"] < 0.1

        # Bohr radius should be positive and in nm range
        assert data["bohr_radius"] > 0
        # GaAs Bohr radius is typically ~10 nm
        assert 1 < data["bohr_radius"] < 100

    def test_calculate_exciton_silicon(self):
        """Test calculate_exciton with Silicon (different properties)"""
        payload = {
            "id": 2,
            "name": "Silicon",
            "formula": "Si",
            "band_gap": 1.12,
            "epsilon": 11.7,
            "effective_mass_e": 0.26,
            "effective_mass_h": 0.38,
            "lattice_constant": 5.43,
        }

        response = client.post("/api/v1/calculate/exciton", json=payload)

        assert response.status_code in [200, 201]
        data = response.json()

        assert data["binding_energy"] > 0
        assert data["bohr_radius"] > 0

    def test_calculate_exciton_invalid_data(self):
        """Test calculate_exciton with invalid data"""
        payload = {}  # Empty payload

        response = client.post("/api/v1/calculate/exciton", json=payload)

        assert response.status_code == 422  # Validation error

    def test_calculate_exciton_zero_epsilon(self):
        """Test calculate_exciton handles zero epsilon input."""
        payload = {
            "id": 3,
            "name": "Invalid Material",
            "formula": "XX",
            "band_gap": 1.0,
            "epsilon": 0.0,  # Invalid: zero
            "effective_mass_e": 0.1,
            "effective_mass_h": 0.1,
            "lattice_constant": 5.0,
        }

        response = client.post("/api/v1/calculate/exciton", json=payload)

        # Should return 500 due to division by zero
        assert response.status_code in [422, 500]


class TestSelectorEndpoints:
    """Test cases for selector endpoints"""

    def test_recommend_solar_success(self):
        """Test recommend_solar endpoint returns materials"""
        response = client.get("/api/v1/selector/solar")

        assert response.status_code == 200
        data = response.json()

        # Should return list of materials
        assert isinstance(data, list)

        # Check material structure if any results
        if len(data) > 0:
            material = data[0]
            assert "band_gap" in material
            assert "name" in material
            assert "formula" in material

            # All materials should have band gap in solar range
            for m in data:
                assert 1.0 <= m["band_gap"] <= 1.8

    def test_recommend_solar_with_top_n(self):
        """Test recommend_solar with top_n parameter"""
        response = client.get("/api/v1/selector/solar?top_n=3")

        assert response.status_code == 200
        data = response.json()

        # Should return at most 3 materials
        assert isinstance(data, list)
        assert len(data) <= 3

    def test_recommend_solar_invalid_top_n(self):
        """Test recommend_solar with invalid top_n (negative)"""
        response = client.get("/api/v1/selector/solar?top_n=-1")

        # Should return validation error
        assert response.status_code == 422

    def test_recommend_led_success(self):
        """Test recommend_led endpoint returns materials"""
        response = client.get("/api/v1/selector/led")

        assert response.status_code == 200
        data = response.json()

        # Should return list of materials
        assert isinstance(data, list)

        # Check material structure if any results
        if len(data) > 0:
            material = data[0]
            assert "band_gap" in material
            assert "name" in material
            assert "formula" in material

            # All materials should have band gap in LED range
            for m in data:
                assert 1.8 <= m["band_gap"] <= 3.5

    def test_recommend_led_with_top_n(self):
        """Test recommend_led with top_n parameter"""
        response = client.get("/api/v1/selector/led?top_n=2")

        assert response.status_code == 200
        data = response.json()

        # Should return at most 2 materials
        assert isinstance(data, list)
        assert len(data) <= 2

    def test_recommend_led_sorted_by_band_gap(self):
        """Test recommend_led returns materials sorted by band gap"""
        response = client.get("/api/v1/selector/led?top_n=10")

        assert response.status_code == 200
        data = response.json()

        # Check sorting (ascending band gap)
        if len(data) > 1:
            band_gaps = [m["band_gap"] for m in data]
            assert band_gaps == sorted(band_gaps)


class TestSecurityAndEdgeCases:
    """Test security and edge cases"""

    def test_xss_prevention_in_material_name(self):
        """Test XSS prevention in material name field"""
        payload = {
            "id": 100,
            "name": "<script>alert('XSS')</script>",
            "formula": "XSS",
            "band_gap": 1.0,
            "epsilon": 10.0,
            "effective_mass_e": 0.1,
            "effective_mass_h": 0.1,
            "lattice_constant": 5.0,
        }

        response = client.post("/api/v1/materials", json=payload)

        # Should either sanitize or accept (null byte validator only)
        assert response.status_code in [200, 201, 422]

    def test_null_byte_prevention(self):
        """Test null byte prevention in string fields"""
        payload = {
            "id": 101,
            "name": "Test\x00Material",  # Null byte
            "formula": "TST",
            "band_gap": 1.0,
            "epsilon": 10.0,
            "effective_mass_e": 0.1,
            "effective_mass_h": 0.1,
            "lattice_constant": 5.0,
        }

        response = client.post("/api/v1/materials", json=payload)

        # Validator should reject null bytes
        assert response.status_code == 422

    def test_whitespace_only_name(self):
        """Test whitespace-only name is rejected"""
        payload = {
            "id": 102,
            "name": "   ",  # Whitespace only
            "formula": "WSP",
            "band_gap": 1.0,
            "epsilon": 10.0,
            "effective_mass_e": 0.1,
            "effective_mass_h": 0.1,
            "lattice_constant": 5.0,
        }

        response = client.post("/api/v1/materials", json=payload)

        # Validator should reject whitespace-only
        assert response.status_code == 422

    def test_extremely_large_band_gap(self):
        """Test extremely large band gap value"""
        payload = {
            "id": 103,
            "name": "Extreme Material",
            "formula": "EXT",
            "band_gap": 1e100,  # Extremely large
            "epsilon": 10.0,
            "effective_mass_e": 0.1,
            "effective_mass_h": 0.1,
            "lattice_constant": 5.0,
        }

        response = client.post("/api/v1/materials", json=payload)

        # Should accept (no upper bound validation)
        assert response.status_code in [200, 201]

    def test_pagination_overflow(self):
        """Test pagination with very large page number"""
        response = client.get("/api/v1/materials/?page=999999&page_size=20")

        # Should return 200 with empty results
        assert response.status_code == 200
        data = response.json()
        assert data["page"] == 999999
        assert isinstance(data["items"], list)

    def test_health_check_no_auth(self):
        """Test health check is accessible without authentication"""
        response = client.get("/api/v1/health")

        assert response.status_code == 200
        data = response.json()
        assert data["success"] is True


class TestRateLimiting:
    """Test rate limiting on endpoints"""

    def test_rate_limit_documentation(self):
        """Verify rate limit is documented in endpoint docstrings"""
        # Documentation test: rate limits are specified but not enforced yet
        # Future: enforce limits with slowapi or fastapi-limiter
        assert True  # Placeholder for future rate limit implementation
